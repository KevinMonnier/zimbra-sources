--- openldap-2.4.33/libraries/liblmdb/lmdb.h.orig	2013-02-04 10:05:20.000000000 -0800
+++ openldap-2.4.33/libraries/liblmdb/lmdb.h	2013-02-16 17:54:17.247188282 -0800
@@ -353,7 +353,9 @@
 #define MDB_CURSOR_FULL	(-30787)
 	/** Page has not enough space - internal error */
 #define MDB_PAGE_FULL	(-30786)
-#define MDB_LAST_ERRCODE	MDB_PAGE_FULL
+	/** Database contents grew beyond environment mapsize */
+#define MDB_MAP_RESIZED	(-30785)
+#define MDB_LAST_ERRCODE	MDB_MAP_RESIZED
 /** @} */
 
 /** @brief Statistics for a database in the environment */
@@ -675,7 +677,9 @@
 	 * errors are:
 	 * <ul>
 	 *	<li>#MDB_PANIC - a fatal error occurred earlier and the environment
-	 *		must be shut down.
+-	 *		must be shut down.
+	 *	<li>#MDB_MAP_RESIZED - another process wrote data beyond this MDB_env's
+	 *		mapsize and the environment must be shut down.
 	 *	<li>ENOMEM - out of memory, or a read-only transaction was requested and
 	 *		the reader lock table is full. See #mdb_env_set_maxreaders().
 	 * </ul>
--- openldap-2.4.33/libraries/liblmdb/mdb.c.orig	2013-02-04 10:05:20.000000000 -0800
+++ openldap-2.4.33/libraries/liblmdb/mdb.c	2013-02-16 17:54:21.407262215 -0800
@@ -911,18 +911,6 @@
 	unsigned char mx_dbflag;
 } MDB_xcursor;
 
-	/** A set of pages freed by an earlier transaction. */
-typedef struct MDB_oldpages {
-	/** Usually we only read one record from the FREEDB at a time, but
-	 *	in case we read more, this will chain them together.
-	 */
-	struct MDB_oldpages *mo_next;
-	/**	The ID of the transaction in which these pages were freed. */
-	txnid_t		mo_txnid;
-	/** An #MDB_IDL of the pages */
-	pgno_t		mo_pages[1];	/* dynamic */
-} MDB_oldpages;
-
 	/** The database environment. */
 struct MDB_env {
 	HANDLE		me_fd;		/**< The main data file */
@@ -949,18 +937,19 @@
 	size_t		me_mapsize;		/**< size of the data memory map */
 	off_t		me_size;		/**< current file size */
 	pgno_t		me_maxpg;		/**< me_mapsize / me_psize */
-	txnid_t		me_pgfirst;		/**< ID of first old page record we used */
 	txnid_t		me_pglast;		/**< ID of last old page record we used */
 	MDB_dbx		*me_dbxs;		/**< array of static DB info */
 	uint16_t	*me_dbflags;	/**< array of flags from MDB_db.md_flags */
-	MDB_oldpages *me_pghead;	/**< list of old page records */
-	MDB_oldpages *me_pgfree;	/**< list of page records to free */
+	pgno_t		*me_pghead;	/**< old pages reclaimed from freelist */
+	pgno_t		*me_pgfree;	/**< memory to free when dropping me_pghead */
 	pthread_key_t	me_txkey;	/**< thread-key for readers */
 	MDB_page	*me_dpages;		/**< list of malloc'd blocks for re-use */
 	/** IDL of pages that became unused in a write txn */
 	MDB_IDL		me_free_pgs;
 	/** ID2L of pages that were written during a write txn */
 	MDB_ID2		me_dirty_list[MDB_IDL_UM_SIZE];
+	/** Max number of freelist items that can fit in a single overflow page */
+	unsigned int	me_maxfree_1pg;
 #ifdef _WIN32
 	HANDLE		me_rmutex;		/* Windows mutexes don't reside in shared mem */
 	HANDLE		me_wmutex;
@@ -1065,7 +1054,8 @@
 	"MDB_TLS_FULL: Thread-local storage keys full - too many environments open",
 	"MDB_TXN_FULL: Transaction has too many dirty pages - transaction too big",
 	"MDB_CURSOR_FULL: Internal error - cursor stack limit reached",
-	"MDB_PAGE_FULL: Internal error - page has no more space"
+	"MDB_PAGE_FULL: Internal error - page has no more space",
+	"MDB_MAP_RESIZED: Database contents grew beyond environment mapsize",
 };
 
 char *
@@ -1095,6 +1085,10 @@
 	char *ptr = buf;
 	unsigned char *c = key->mv_data;
 	unsigned int i;
+
+	if (!key)
+		return "";
+
 	if (key->mv_size > MDB_MAXKEYSIZE)
 		return "MDB_MAXKEYSIZE";
 	/* may want to make this a dynamic check: if the key is mostly
@@ -1283,7 +1277,6 @@
 	 * after txn 3 commits, and so will be safe to re-use in txn 4.
 	 */
 	if (txn->mt_txnid > 3) {
-
 		if (!txn->mt_env->me_pghead &&
 			txn->mt_dbs[FREE_DBI].md_root != P_INVALID) {
 			/* See if there's anything in the free DB */
@@ -1294,7 +1287,7 @@
 			txnid_t *kptr;
 
 			mdb_cursor_init(&m2, txn, FREE_DBI, NULL);
-			if (!txn->mt_env->me_pgfirst) {
+			if (!txn->mt_env->me_pglast) {
 				mdb_page_search(&m2, NULL, 0);
 				leaf = NODEPTR(m2.mc_pg[m2.mc_top], 0);
 				kptr = (txnid_t *)NODEKEY(leaf);
@@ -1331,33 +1324,31 @@
 			if (oldest > last) {
 				/* It's usable, grab it.
 				 */
-				MDB_oldpages *mop;
-				pgno_t *idl;
+				pgno_t *idl, *mop;
 
-				if (!txn->mt_env->me_pgfirst) {
+				if (!txn->mt_env->me_pglast) {
 					mdb_node_read(txn, leaf, &data);
 				}
-				txn->mt_env->me_pglast = last;
-				if (!txn->mt_env->me_pgfirst)
-					txn->mt_env->me_pgfirst = last;
 				idl = (MDB_ID *) data.mv_data;
 				/* We might have a zero-length IDL due to freelist growth
 				 * during a prior commit
 				 */
-				if (!idl[0]) goto again;
-				mop = malloc(sizeof(MDB_oldpages) + MDB_IDL_SIZEOF(idl) - sizeof(pgno_t));
+				if (!idl[0]) {
+					txn->mt_env->me_pglast = last;
+					goto again;
+				}
+				mop = malloc(MDB_IDL_SIZEOF(idl));
 				if (!mop)
 					return ENOMEM;
-				mop->mo_next = txn->mt_env->me_pghead;
-				mop->mo_txnid = last;
-				txn->mt_env->me_pghead = mop;
-				memcpy(mop->mo_pages, idl, MDB_IDL_SIZEOF(idl));
+				txn->mt_env->me_pglast = last;
+				txn->mt_env->me_pghead = txn->mt_env->me_pgfree = mop;
+				memcpy(mop, idl, MDB_IDL_SIZEOF(idl));
 
 #if MDB_DEBUG > 1
 				{
 					unsigned int i;
 					DPRINTF("IDL read txn %zu root %zu num %zu",
-						mop->mo_txnid, txn->mt_dbs[FREE_DBI].md_root, idl[0]);
+						last, txn->mt_dbs[FREE_DBI].md_root, idl[0]);
 					for (i=0; i<idl[0]; i++) {
 						DPRINTF("IDL %zu", idl[i+1]);
 					}
@@ -1367,14 +1358,14 @@
 		}
 none:
 		if (txn->mt_env->me_pghead) {
-			MDB_oldpages *mop = txn->mt_env->me_pghead;
+			pgno_t *mop = txn->mt_env->me_pghead;
 			if (num > 1) {
 				MDB_cursor m2;
-				int retry = 500, readit = 0, n2 = num-1;
+				int retry = 1, readit = 0, n2 = num-1;
 				unsigned int i, j, k;
 
 				/* If current list is too short, must fetch more and coalesce */
-				if (mop->mo_pages[0] < (unsigned)num)
+				if (mop[0] < (unsigned)num)
 					readit = 1;
 
 				mdb_cursor_init(&m2, txn, FREE_DBI, NULL);
@@ -1389,11 +1380,10 @@
 					}
 					if (readit) {
 						MDB_val key, data;
-						MDB_oldpages *mop2;
-						pgno_t *idl;
+						pgno_t *idl, *mop2;
 						int exact;
 
-						last = mop->mo_txnid + 1;
+						last = txn->mt_env->me_pglast + 1;
 
 						/* We haven't hit the readers list yet? */
 						if (!oldest) {
@@ -1423,63 +1413,55 @@
 						if (rc)
 							return rc;
 						idl = (MDB_ID *) data.mv_data;
-						mop2 = malloc(sizeof(MDB_oldpages) + MDB_IDL_SIZEOF(idl) - 2*sizeof(pgno_t) + MDB_IDL_SIZEOF(mop->mo_pages));
+						mop2 = malloc(MDB_IDL_SIZEOF(idl) + MDB_IDL_SIZEOF(mop));
 						if (!mop2)
 							return ENOMEM;
 						/* merge in sorted order */
-						i = idl[0]; j = mop->mo_pages[0]; mop2->mo_pages[0] = k = i+j;
-						mop->mo_pages[0] = P_INVALID;
+						i = idl[0]; j = mop[0]; mop2[0] = k = i+j;
+						mop[0] = P_INVALID;
 						while (i>0  || j>0) {
-							if (i && idl[i] < mop->mo_pages[j])
-								mop2->mo_pages[k--] = idl[i--];
+							if (i && idl[i] < mop[j])
+								mop2[k--] = idl[i--];
 							else
-								mop2->mo_pages[k--] = mop->mo_pages[j--];
+								mop2[k--] = mop[j--];
 						}
 						txn->mt_env->me_pglast = last;
-						mop2->mo_txnid = last;
-						mop2->mo_next = mop->mo_next;
-						txn->mt_env->me_pghead = mop2;
-						free(mop);
+						free(txn->mt_env->me_pgfree);
+						txn->mt_env->me_pghead = txn->mt_env->me_pgfree = mop2;
 						mop = mop2;
 						/* Keep trying to read until we have enough */
-						if (mop->mo_pages[0] < (unsigned)num) {
+						if (mop[0] < (unsigned)num) {
 							continue;
 						}
 					}
 
 					/* current list has enough pages, but are they contiguous? */
-					for (i=mop->mo_pages[0]; i>=(unsigned)num; i--) {
-						if (mop->mo_pages[i-n2] == mop->mo_pages[i] + n2) {
-							pgno = mop->mo_pages[i];
+					for (i=mop[0]; i>=(unsigned)num; i--) {
+						if (mop[i-n2] == mop[i] + n2) {
+							pgno = mop[i];
 							i -= n2;
 							/* move any stragglers down */
-							for (j=i+num; j<=mop->mo_pages[0]; j++)
-								mop->mo_pages[i++] = mop->mo_pages[j];
-							mop->mo_pages[0] -= num;
+							for (j=i+num; j<=mop[0]; j++)
+								mop[i++] = mop[j];
+							mop[0] -= num;
 							break;
 						}
 					}
 
-					/* Stop if we succeeded, or no more retries */
+					/* Stop if we succeeded, or no retries */
 					if (!retry || pgno != P_INVALID)
 						break;
 					readit = 1;
-					retry--;
 
 				} while (1);
 			} else {
 				/* peel pages off tail, so we only have to truncate the list */
-				pgno = MDB_IDL_LAST(mop->mo_pages);
-				mop->mo_pages[0]--;
+				pgno = MDB_IDL_LAST(mop);
+				mop[0]--;
 			}
-			if (MDB_IDL_IS_ZERO(mop->mo_pages)) {
-				txn->mt_env->me_pghead = mop->mo_next;
-				if (mc->mc_dbi == FREE_DBI) {
-					mop->mo_next = txn->mt_env->me_pgfree;
-					txn->mt_env->me_pgfree = mop;
-				} else {
-					free(mop);
-				}
+			if (MDB_IDL_IS_ZERO(mop)) {
+				free(txn->mt_env->me_pgfree);
+				txn->mt_env->me_pghead = txn->mt_env->me_pgfree = NULL;
 			}
 		}
 	}
@@ -1836,6 +1818,11 @@
 	if (txn->mt_numdbs > 2)
 		memset(txn->mt_dbflags+2, DB_STALE, txn->mt_numdbs-2);
 
+	if (env->me_maxpg < txn->mt_next_pgno) {
+		mdb_txn_reset0(txn);
+		return MDB_MAP_RESIZED;
+	}
+
 	return MDB_SUCCESS;
 }
 
@@ -1952,7 +1939,6 @@
 		if (!(env->me_flags & MDB_ROFS))
 			txn->mt_u.reader->mr_txnid = (txnid_t)-1;
 	} else {
-		MDB_oldpages *mop;
 		MDB_page *dp;
 		unsigned int i;
 
@@ -1992,11 +1978,8 @@
 				env->me_free_pgs = txn->mt_free_pgs;
 		}
 
-		while ((mop = txn->mt_env->me_pghead)) {
-			txn->mt_env->me_pghead = mop->mo_next;
-			free(mop);
-		}
-		txn->mt_env->me_pgfirst = 0;
+		free(txn->mt_env->me_pgfree);
+		txn->mt_env->me_pghead = txn->mt_env->me_pgfree = NULL;
 		txn->mt_env->me_pglast = 0;
 
 		env->me_txn = NULL;
@@ -2045,6 +2028,7 @@
 	MDB_page	*dp;
 	MDB_env	*env;
 	pgno_t	next, freecnt;
+	txnid_t	oldpg_txnid, id;
 	MDB_cursor mc;
 
 	assert(txn != NULL);
@@ -2078,22 +2062,19 @@
 	}
 
 	if (txn->mt_parent) {
-		MDB_db *ip, *jp;
-		MDB_dbi i;
+		MDB_txn *parent = txn->mt_parent;
 		unsigned x, y;
 		MDB_ID2L dst, src;
 
+		parent->mt_next_pgno = txn->mt_next_pgno;
+		parent->mt_flags = txn->mt_flags;
+
 		/* Merge (and close) our cursors with parent's */
 		mdb_cursor_merge(txn);
 
-		/* Update parent's DB table */
-		ip = &txn->mt_parent->mt_dbs[2];
-		jp = &txn->mt_dbs[2];
-		for (i = 2; i < txn->mt_numdbs; i++) {
-			if (ip->md_root != jp->md_root)
-				*ip = *jp;
-			ip++; jp++;
-		}
+		/* Update parent's DB table. */
+		memcpy(parent->mt_dbs, txn->mt_dbs, txn->mt_numdbs * sizeof(MDB_db));
+		memcpy(parent->mt_dbflags, txn->mt_dbflags, txn->mt_numdbs);
 		txn->mt_parent->mt_numdbs = txn->mt_numdbs;
 
 		/* Append our free list to parent's */
@@ -2123,6 +2104,7 @@
 		dst[0].mid = x;
 		free(txn->mt_u.dirty_list);
 		txn->mt_parent->mt_child = NULL;
+		txn->mt_parent->mt_next_pgno = txn->mt_next_pgno;
 		free(txn);
 		return MDB_SUCCESS;
 	}
@@ -2139,9 +2121,7 @@
 	DPRINTF("committing txn %zu %p on mdbenv %p, root page %zu",
 	    txn->mt_txnid, (void *)txn, (void *)env, txn->mt_dbs[MAIN_DBI].md_root);
 
-	/* Update DB root pointers. Their pages have already been
-	 * touched so this is all in-place and cannot fail.
-	 */
+	/* Update DB root pointers */
 	if (txn->mt_numdbs > 2) {
 		MDB_dbi i;
 		MDB_val data;
@@ -2151,15 +2131,29 @@
 		for (i = 2; i < txn->mt_numdbs; i++) {
 			if (txn->mt_dbflags[i] & DB_DIRTY) {
 				data.mv_data = &txn->mt_dbs[i];
-				mdb_cursor_put(&mc, &txn->mt_dbxs[i].md_name, &data, 0);
+				rc = mdb_cursor_put(&mc, &txn->mt_dbxs[i].md_name, &data, 0);
+				if (rc)
+					goto fail;
 			}
 		}
 	}
 
+	/* Save the freelist as of this transaction to the freeDB. This
+	 * can change the freelist, so keep trying until it stabilizes.
+	 *
+	 * env->me_pglast and the length of txn->mt_free_pgs cannot decrease,
+	 * except the code below can decrease env->me_pglast to split pghead.
+	 * Page numbers cannot disappear from txn->mt_free_pgs.  New pages
+	 * can only appear in env->me_pghead when env->me_pglast increases.
+	 * Until then, the me_pghead pointer won't move but can become NULL.
+	 */
+
 	mdb_cursor_init(&mc, txn, FREE_DBI, NULL);
+	oldpg_txnid = id = 0;
+	freecnt = 0;
 
 	/* should only be one record now */
-	if (env->me_pghead || env->me_pgfirst) {
+	if (env->me_pghead || env->me_pglast) {
 		/* make sure first page of freeDB is touched and on freelist */
 		rc = mdb_page_search(&mc, NULL, MDB_PS_MODIFY);
 		if (rc && rc != MDB_NOTFOUND) {
@@ -2170,28 +2164,27 @@
 	}
 
 	/* Delete IDLs we used from the free list */
-	if (env->me_pgfirst) {
-		txnid_t cur;
+	if (env->me_pglast) {
 		MDB_val key;
-		int exact = 0;
-
-		key.mv_size = sizeof(cur);
-		for (cur = env->me_pgfirst; cur <= env->me_pglast; cur++) {
-			key.mv_data = &cur;
 
-			mdb_cursor_set(&mc, &key, NULL, MDB_SET, &exact);
+		do {
+free_pgfirst:
+			rc = mdb_cursor_first(&mc, &key, NULL);
+			if (rc)
+				goto fail;
+			oldpg_txnid = *(txnid_t *)key.mv_data;
+again:
+			assert(oldpg_txnid <= env->me_pglast);
+			id = 0;
 			rc = mdb_cursor_del(&mc, 0);
 			if (rc)
 				goto fail;
-		}
-		env->me_pgfirst = 0;
-		env->me_pglast = 0;
+		} while (oldpg_txnid < env->me_pglast);
 	}
 
-	/* save to free list */
+	/* Save IDL of pages freed by this txn, to freeDB */
 free2:
-	freecnt = txn->mt_free_pgs[0];
-	if (!MDB_IDL_IS_ZERO(txn->mt_free_pgs)) {
+	if (freecnt != txn->mt_free_pgs[0]) {
 		MDB_val key, data;
 
 		/* make sure last page of freeDB is touched and on freelist */
@@ -2216,77 +2209,70 @@
 		/* write to last page of freeDB */
 		key.mv_size = sizeof(pgno_t);
 		key.mv_data = &txn->mt_txnid;
-		data.mv_data = txn->mt_free_pgs;
 		/* The free list can still grow during this call,
-		 * despite the pre-emptive touches above. So check
-		 * and make sure the entire thing got written.
+		 * despite the pre-emptive touches above. So retry
+		 * until the reserved space remains big enough.
 		 */
 		do {
+			assert(freecnt < txn->mt_free_pgs[0]);
 			freecnt = txn->mt_free_pgs[0];
 			data.mv_size = MDB_IDL_SIZEOF(txn->mt_free_pgs);
-			mdb_midl_sort(txn->mt_free_pgs);
-			rc = mdb_cursor_put(&mc, &key, &data, 0);
+			rc = mdb_cursor_put(&mc, &key, &data, MDB_RESERVE);
 			if (rc)
 				goto fail;
 		} while (freecnt != txn->mt_free_pgs[0]);
+		mdb_midl_sort(txn->mt_free_pgs);
+		memcpy(data.mv_data, txn->mt_free_pgs, data.mv_size);
+		if (oldpg_txnid < env->me_pglast || (!env->me_pghead && id))
+			goto free_pgfirst;	/* used up freeDB[oldpg_txnid] */
 	}
-	/* should only be one record now */
-again:
+
+	/* Put back page numbers we took from freeDB but did not use */
 	if (env->me_pghead) {
+	  for (;;) {
 		MDB_val key, data;
-		MDB_oldpages *mop;
-		pgno_t orig;
-		txnid_t id;
+		pgno_t orig, *mop;
 
 		mop = env->me_pghead;
-		id = mop->mo_txnid;
+		id = env->me_pglast;
 		key.mv_size = sizeof(id);
 		key.mv_data = &id;
-		data.mv_size = MDB_IDL_SIZEOF(mop->mo_pages);
-		data.mv_data = mop->mo_pages;
-		orig = mop->mo_pages[0];
 		/* These steps may grow the freelist again
 		 * due to freed overflow pages...
 		 */
-		rc = mdb_cursor_put(&mc, &key, &data, 0);
-		if (rc)
-			goto fail;
-		if (mop == env->me_pghead && env->me_pghead->mo_txnid == id) {
-			/* could have been used again here */
-			if (mop->mo_pages[0] != orig) {
-				data.mv_size = MDB_IDL_SIZEOF(mop->mo_pages);
-				data.mv_data = mop->mo_pages;
-				id = mop->mo_txnid;
-				rc = mdb_cursor_put(&mc, &key, &data, 0);
-				if (rc)
-					goto fail;
-			}
-		} else {
-			/* was completely used up */
-			rc = mdb_cursor_del(&mc, 0);
+		i = 2;
+		do {
+			orig = mop[0];
+			if (orig > env->me_maxfree_1pg && id > 4)
+				orig = env->me_maxfree_1pg; /* Do not use more than 1 page */
+			data.mv_size = (orig + 1) * sizeof(pgno_t);
+			rc = mdb_cursor_put(&mc, &key, &data, MDB_RESERVE);
 			if (rc)
 				goto fail;
-			if (env->me_pghead)
-				goto again;
-		}
-		env->me_pgfirst = 0;
-		env->me_pglast = 0;
+			assert(!env->me_pghead || env->me_pglast);
+			/* mop could have been used again here */
+			if (id != env->me_pglast || env->me_pghead == NULL)
+				goto again;		/* was completely used up */
+			assert(mop == env->me_pghead);
+		} while (mop[0] < orig && --i);
+		memcpy(data.mv_data, mop, data.mv_size);
+		if (mop[0] <= orig)
+			break;
+		*(pgno_t *)data.mv_data = orig;
+		mop[orig] = mop[0] - orig;
+		env->me_pghead = mop += orig;
+		/* Save more oldpages at the previous txnid. */
+		assert(env->me_pglast == id && id == oldpg_txnid);
+		env->me_pglast = --oldpg_txnid;
+	  }
 	}
 
 	/* Check for growth of freelist again */
 	if (freecnt != txn->mt_free_pgs[0])
 		goto free2;
 
-	if (env->me_pghead) {
-		free(env->me_pghead);
-		env->me_pghead = NULL;
-	}
-
-	while (env->me_pgfree) {
-		MDB_oldpages *mop = env->me_pgfree;
-		env->me_pgfree = mop->mo_next;
-		free(mop);
-	}
+	free(env->me_pgfree);
+	env->me_pghead = env->me_pgfree = NULL;
 
 	if (!MDB_IDL_IS_ZERO(txn->mt_free_pgs)) {
 		if (mdb_midl_shrink(&txn->mt_free_pgs))
@@ -2422,6 +2408,7 @@
 	}
 
 done:
+	env->me_pglast = 0;
 	env->me_txn = NULL;
 	if (txn->mt_numdbs > env->me_numdbs) {
 		/* update the DB flags */
@@ -2849,6 +2836,7 @@
 		return EBUSY;	/* TODO: Make a new MDB_* error code? */
 	}
 	env->me_psize = meta.mm_psize;
+	env->me_maxfree_1pg = (env->me_psize - PAGEHDRSZ) / sizeof(pgno_t) - 1;
 
 	env->me_maxpg = env->me_mapsize / env->me_psize;
 
@@ -3919,28 +3907,31 @@
 {
 	MDB_page *p = NULL;
 
-	if (txn->mt_env->me_flags & MDB_WRITEMAP) {
-		if (pgno < txn->mt_next_pgno)
-			p = (MDB_page *)(txn->mt_env->me_map + txn->mt_env->me_psize * pgno);
-		goto done;
-	}
-	if (!F_ISSET(txn->mt_flags, MDB_TXN_RDONLY) && txn->mt_u.dirty_list[0].mid) {
-		unsigned x;
-		x = mdb_mid2l_search(txn->mt_u.dirty_list, pgno);
-		if (x <= txn->mt_u.dirty_list[0].mid && txn->mt_u.dirty_list[x].mid == pgno) {
-			p = txn->mt_u.dirty_list[x].mptr;
-		}
-	}
-	if (!p) {
-		if (pgno < txn->mt_next_pgno)
-			p = (MDB_page *)(txn->mt_env->me_map + txn->mt_env->me_psize * pgno);
+	if (!((txn->mt_flags & MDB_TXN_RDONLY) |
+		  (txn->mt_env->me_flags & MDB_WRITEMAP)))
+	{
+		MDB_txn *tx2 = txn;
+		do {
+			MDB_ID2L dl = tx2->mt_u.dirty_list;
+			if (dl[0].mid) {
+				unsigned x = mdb_mid2l_search(dl, pgno);
+				if (x <= dl[0].mid && dl[x].mid == pgno) {
+					p = dl[x].mptr;
+					goto done;
+				}
+			}
+		} while ((tx2 = tx2->mt_parent) != NULL);
 	}
-done:
-	*ret = p;
-	if (!p) {
+
+	if (pgno < txn->mt_next_pgno) {
+		p = (MDB_page *)(txn->mt_env->me_map + txn->mt_env->me_psize * pgno);
+	} else {
 		DPRINTF("page %zu not found", pgno);
 		assert(p != NULL);
 	}
+
+done:
+	*ret = p;
 	return (p != NULL) ? MDB_SUCCESS : MDB_PAGE_NOTFOUND;
 }
 
@@ -4819,7 +4810,7 @@
 	if (F_ISSET(mc->mc_txn->mt_flags, MDB_TXN_RDONLY))
 		return EACCES;
 
-	if (key->mv_size == 0 || key->mv_size > MDB_MAXKEYSIZE)
+	if (flags != MDB_CURRENT && (key->mv_size == 0 || key->mv_size > MDB_MAXKEYSIZE))
 		return EINVAL;
 
 	if (F_ISSET(mc->mc_db->md_flags, MDB_DUPSORT) && data->mv_size > MDB_MAXKEYSIZE)
@@ -7155,8 +7146,10 @@
 	/* Can't delete the main DB */
 	if (del && dbi > MAIN_DBI) {
 		rc = mdb_del(txn, MAIN_DBI, &mc->mc_dbx->md_name, NULL);
-		if (!rc)
+		if (!rc) {
+			txn->mt_dbflags[dbi] = DB_STALE;
 			mdb_dbi_close(txn->mt_env, dbi);
+		}
 	} else {
 		/* reset the DB record, mark it dirty */
 		txn->mt_dbflags[dbi] |= DB_DIRTY;
--- openldap-2.4.33/libraries/liblmdb/mdb_stat.1.orig	2013-02-04 10:05:20.000000000 -0800
+++ openldap-2.4.33/libraries/liblmdb/mdb_stat.1	2013-02-16 17:54:27.217194853 -0800
@@ -9,7 +9,7 @@
 [\c
 .BR \-e ]
 [\c
-.BR \-f [ f ]]
+.BR \-f [ f [ f ]]]
 [\c
 .BR \-n ]
 [\c
@@ -25,8 +25,9 @@
 Display information about the database environment.
 .TP
 .BR \-f
-Display information about the environment freelist. If \fB\-ff\fP is given,
-display the full list of page IDs in the freelist.
+Display information about the environment freelist.
+If \fB\-ff\fP is given, summarize each freelist entry.
+If \fB\-fff\fP is given, display the full list of page IDs in the freelist.
 .TP
 .BR \-n
 Display the status of an LMDB database which does not use subdirectories.
--- openldap-2.4.33/libraries/liblmdb/mdb_stat.c.orig	2013-02-04 10:05:20.000000000 -0800
+++ openldap-2.4.33/libraries/liblmdb/mdb_stat.c	2013-02-16 17:54:29.067193811 -0800
@@ -1,6 +1,6 @@
 /* mdb_stat.c - memory-mapped database status tool */
 /*
- * Copyright 2011 Howard Chu, Symas Corp.
+ * Copyright 2011-2013 Howard Chu, Symas Corp.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -31,7 +31,7 @@
 
 static void usage(char *prog)
 {
-	fprintf(stderr, "usage: %s dbpath [-e] [-f[f]] [-n] [-a|-s subdb]\n", prog);
+	fprintf(stderr, "usage: %s dbpath [-e] [-f[f[f]]] [-n] [-a|-s subdb]\n", prog);
 	exit(EXIT_FAILURE);
 }
 
@@ -142,12 +142,28 @@
 			iptr = data.mv_data;
 			pages += *iptr;
 			if (freinfo > 1) {
-				size_t i, j;
+				char *bad = "";
+				size_t pg, prev;
+				ssize_t i, j, span = 0;
 				j = *iptr++;
-				printf("    Transaction %zu, %zu pages\n",
-					*(size_t *)key.mv_data, j);
-				for (i=0; i<j; i++)
-					printf("      %zu\n", iptr[i]);
+				for (i = j, prev = 1; --i >= 0; ) {
+					pg = iptr[i];
+					if (pg <= prev)
+						bad = " [bad sequence]";
+					prev = pg;
+					pg += span;
+					for (; i >= span && iptr[i-span] == pg; span++, pg++) ;
+				}
+				printf("    Transaction %zu, %zd pages, maxspan %zd%s\n",
+					*(size_t *)key.mv_data, j, span, bad);
+				if (freinfo > 2) {
+					for (--j; j >= 0; ) {
+						pg = iptr[j];
+						for (span=1; --j >= 0 && iptr[j] == pg+span; span++) ;
+						printf(span>1 ? "     %9zu[%zd]\n" : "     %9zu\n",
+							pg, span);
+					}
+				}
 			}
 		}
 		mdb_cursor_close(cursor);
